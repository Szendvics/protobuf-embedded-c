package edu.tum.cs.ccts.protobuf.embedded

import java.io.File
import java.io.FileWriter
import org.antlr.runtime.tree.CommonTree

import static extension edu.tum.cs.ccts.protobuf.embedded.TreeUtils.*

class EmbeddedCGenerator {
	
	val typeMap = newHashMap(   "double"->"double",
  							    "float"->"float",
  								"int32"->"signed long",
  								"int64"->"signed long long",
  								"uint32"->"unsigned long",
  								"uint64"->"unsigned long long",
  								"sint32"->"signed long",
  								"sint64"->"signed long long",
  								"fixed32"->"unsigned long",
  								"fixed64"->"unsigned long long",
  								"sfixed32"->"signed long",
  								"sfixed64"->"signed long long",
  								"bool"->"char",
  								"string"->"char",
  								"bytes"->"char"
  	);
  
    val arrayTypes = newHashMap(  "string"->"[MAX_STRING_LENGTH]", 
    							  "bytes"->"[MAX_BYTES_LENGTH]"
    ); 
	
	def doGenerate(File outputDirectory, String name, CommonTree tree) {
		generateFile(new File(outputDirectory, name + ".h"), tree.compileHeader(name))
		generateFile(new File(outputDirectory, name + ".c"), tree.compileImplementation(name))
	}

	
	def compileHeader(CommonTree tree, String name) '''
		/******************************************************************* 
		 * Header file generated by Protoc for Embedded C.                 *
		 * Version «Protoc::VERSION»                                      *
		 *                                                                 *
		 * Copyright (c) 2009-2013                                         *
		 * Technische Universitaet Muenchen                                *
		 * http://www4.in.tum.de/                                          *
		 *                                                                 *
		 * Source : «name.toFirstUpper».proto
		 *                                                                 *
		 * Do not edit.                                                    *
		 *******************************************************************/

		#ifndef _«name.toFirstUpper»_H
		#define _«name.toFirstUpper»_H
		
		#ifdef __cplusplus
		  extern "C" {
		#endif
		
		«FOR d : tree.childTrees.filter[it.type == ProtoParser::ANNOTATION]»
			«d.getDefine»
		«ENDFOR»
		
		/*******************************************************************
		 * General functions
		 *******************************************************************/
		
		/*
		 * returns the size of a length delimited message which also 
		 * contains the first bytes for the length encoding.
		 */
		unsigned long Message_get_delimited_size(void *_buffer, int offset);
		
		/*
		 * Tests whether a message can be completely read from the given buffer at
		 * the offset. The bytes [offset..offset+length-1] are interpreted.
		 *
		 * Returns 1 (true) if buffer[offset..offset+length-1] contains a complete
		 * message or 0 (false) otherwise.
		 */
		int Message_can_read_delimited_from(void *_buffer, int offset, unsigned int length);
		
		
		«FOR e : tree.childTrees.filter[it.type == ProtoParser::ENUM]»
		 /*******************************************************************
		 * Enumerations: «name.toFirstUpper».proto
		 *******************************************************************/
		 «e.getEnum»
		 
		«ENDFOR»	
		
		
		«FOR m : tree.childTrees.filter[it.type == ProtoParser::MESSAGE]»
		/*******************************************************************
		 * Message: «name.toFirstUpper».proto
		 *******************************************************************/
		«m.getMessage»
		
		/*
		 * Serialize a Person-message into the given buffer at offset and return
		 * new offset for optional next message.
		 */
		int «m.getMessageName»_write_delimited_to(struct «m.getMessageName» *_«m.getMessageName», void *_buffer, int offset);
		
		/*
		 * Serialize a Person-message together with its tag into the given buffer 
		 * at offset and return new offset for optional next message.
		 * Is useful if a Person-message is embedded in another message.
		 */
		int «m.getMessageName»_write_with_tag(struct «m.getMessageName» *_«m.getMessageName», void *_buffer, int offset, int tag);
		
		/*
		 * Deserialize a Person-message from the given buffer at offset and return
		 * new offset for optional next message.
		 *
		 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
		 */
		int «m.getMessageName»_read_delimited_from(void *_buffer, struct «m.getMessageName» *_«m.getMessageName», int offset);
		
		
		«ENDFOR»
«««			 
«««		// ... some examples for accessing nodes in a CommonTree
«««		
«««		// ... iterate over all children (and list their respective children) 
«««		«FOR c : tree.children as List<CommonTree>»
«««			«c.text» «c.childText(".")»
«««		«ENDFOR»
«««		
«««		// ... access child node with a certain token type (e.g. PACKAGE)
«««		«tree.getFirstChildWithType(ProtoParser::ANNOTATION)»
«««		
«««		// all options
«««		«FOR t : tree.childTrees.filter[it.type == ProtoParser::OPTION]»
«««			«t.childText(" ")»
«««		«ENDFOR»
		
		#ifdef __cplusplus
		  }
		#endif
		
		#endif
	'''
	
	
	def getMessageName(CommonTree m) { 
		val name = m.children.get(0) as CommonTree
		
		name.text
	}

	
	def getMessage(CommonTree m) { 
		var messageValue = new StringBuilder()
		val name = m.children.get(0) as CommonTree
		
		messageValue.append("/* Structure that holds a deserialized " + name.text + "-message. */\n");
		messageValue.append("struct ");
		
		messageValue.append(name.text + " {\n");
		
		val indent = "    "
		var i = 1;
		while(i < m.children.size()) {
			val modifier = (m.children.get(i) as CommonTree).children.get(0) as CommonTree
			val type = (m.children.get(i) as CommonTree).children.get(1) as CommonTree
			val attrName = (m.children.get(i) as CommonTree).children.get(2) as CommonTree
			
			var cType = typeMap.get(type.text);
			
			if (cType == null)
				cType = "struct " + type.text;
				
			var repValue = ""
			if (modifier.text.equals("repeated")) {
				repValue = "[MAX_REPEATED_LENGTH]"
			}
			
			var	typeArrayValue = arrayTypes.get(type.text)
			if (typeArrayValue == null) {
				typeArrayValue = ""
			}
			
			if (!repValue.equals("")) {
				messageValue.append(indent + "int" + " _" + attrName.text 
									+ "_repeated_len" + ";\n"
				);
			}
			if (!typeArrayValue.equals("")) {
				messageValue.append(indent + "int" + " _" + attrName.text + "_len" 
									+ repValue + ";\n"
				);
			}
			
			messageValue.append(indent + cType + " _" + attrName.text 
									+ repValue + typeArrayValue + ";\n")
			
			i = i + 1
		}  
		messageValue.append("}")
		
		messageValue.toString
	}

	
	def getEnum(CommonTree e) { 
		var enumValue = new StringBuilder()
		enumValue.append("enum ");
		
		val name = e.children.get(0) as CommonTree
		
		enumValue.append(name + " {\n");
		
		val indent = "    "
		var i = 1;
		while(i < e.children.size()-1) {
			val value = (e.children.get(i) as CommonTree).children.get(0) as CommonTree
			val id = (e.children.get(i) as CommonTree).children.get(1) as CommonTree
			
			enumValue.append(indent + "_" + value.text + " = " + id.text + ",\n")
			
			i = i + 1
		}  
		val value = (e.children.get(i) as CommonTree).children.get(0) as CommonTree
		val id = (e.children.get(i) as CommonTree).children.get(1) as CommonTree
			
		enumValue.append(indent + "_" + value.text + " = " + id.text + "\n")
		enumValue.append("}")
		
		enumValue.toString
	}
	
	
	def getDefine(CommonTree d) {
		var define = "#define "
		
		val literal = d.children.get(0) as CommonTree
		val number = d.children.get(1) as CommonTree
		define = define + literal.text.toUpperCase + " "
		define = define + number.text
	}



	def CharSequence compileImplementation(CommonTree tree, String name) '''
		/******************************************************************* 
		 * C file generated by Protoc for Embedded C.                      *
		 * Version «Protoc::VERSION»                                      *
		 *                                                                 *
		 * Copyright (c) 2009-2013                                         *
		 * Technische Universitaet Muenchen                                *
		 * http://www4.in.tum.de/                                          *
		 *                                                                 *
		 * Source : «name».proto
		 *                                                                 *
		 * Do not edit.                                                    *
		 *******************************************************************/
		 
		#include "«name».h"
	'''
	
	
	/**
	 * Creates the given file and writes the given contents to it.
	 */
	def generateFile(File file, CharSequence contents) {
		val writer = new FileWriter(file, false)
		writer.write(contents.toString)
		writer.close
	}
	 
}